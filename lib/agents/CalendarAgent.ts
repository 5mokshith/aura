import{google}from"googleapis";
import{Agent,ExecutionContext,ExecutionResult}from"./base";

/**
*CalendarAgenthandlesGoogleCalendaroperationsincludingcreating,listing,updating,anddeletingevents
*/
exportclassCalendarAgentimplementsAgent{
name="CalendarAgent";

asyncexecute(context:ExecutionContext):Promise<ExecutionResult>{
try{
//InitializeCalendarAPIclientwithOAuthtoken
constauth=newgoogle.auth.OAuth2();
auth.setCredentials({access_token:context.accessToken});
constcalendar=google.calendar({version:"v3",auth});

//Routetoappropriateactionhandler
switch(context.action){
case"create_event":
returnawaitthis.createEvent(calendar,context.parameters);
case"list_events":
returnawaitthis.listEvents(calendar,context.parameters);
case"update_event":
returnawaitthis.updateEvent(calendar,context.parameters);
case"delete_event":
returnawaitthis.deleteEvent(calendar,context.parameters);
default:
return{
success:false,
error:`Unknownaction:${context.action}`,
};
}
}catch(error){
return{
success:false,
error:`CalendarAgentexecutionfailed:${errorinstanceofError?error.message:"Unknownerror"}`,
};
}
}

/**
*Createanewcalendarevent
*/
privateasynccreateEvent(
calendar:any,
parameters:Record<string,any>
):Promise<ExecutionResult>{
try{
const{
summary,
description,
startDateTime,
endDateTime,
timeZone="UTC",
attendees,
location,
calendarId="primary",
}=parameters;

if(!summary||!startDateTime||!endDateTime){
return{
success:false,
error:"Missingrequiredparameters:summary,startDateTime,endDateTime",
};
}

//Constructeventobject
constevent:any={
summary,
description,
location,
start:{
dateTime:startDateTime,
timeZone,
},
end:{
dateTime:endDateTime,
timeZone,
},
};

//Addattendeesifprovided
if(attendees&&Array.isArray(attendees)){
event.attendees=attendees.map((email:string)=>({email}));
}

constresponse=awaitcalendar.events.insert({
calendarId,
requestBody:event,
sendUpdates:"all",//Sendemailnotificationstoattendees
});

return{
success:true,
output:{
eventId:response.data.id,
htmlLink:response.data.htmlLink,
summary:response.data.summary,
start:response.data.start,
end:response.data.end,
},
};
}catch(error){
return{
success:false,
error:`Failedtocreateevent:${errorinstanceofError?error.message:"Unknownerror"}`,
};
}
}

/**
*Listcalendareventswithinatimerange
*/
privateasynclistEvents(
calendar:any,
parameters:Record<string,any>
):Promise<ExecutionResult>{
try{
const{
timeMin,
timeMax,
maxResults=10,
calendarId="primary",
query,
}=parameters;

constlistParams:any={
calendarId,
maxResults,
singleEvents:true,
orderBy:"startTime",
};

//Addtimerangefiltersifprovided
if(timeMin){
listParams.timeMin=timeMin;
}
if(timeMax){
listParams.timeMax=timeMax;
}
if(query){
listParams.q=query;
}

constresponse=awaitcalendar.events.list(listParams);

constevents=(response.data.items||[]).map((event:any)=>({
id:event.id,
summary:event.summary,
description:event.description,
location:event.location,
start:event.start,
end:event.end,
htmlLink:event.htmlLink,
attendees:event.attendees?.map((a:any)=>({
email:a.email,
responseStatus:a.responseStatus,
})),
}));

return{
success:true,
output:{
events,
eventCount:events.length,
},
};
}catch(error){
return{
success:false,
error:`Failedtolistevents:${errorinstanceofError?error.message:"Unknownerror"}`,
};
}
}

/**
*Updateanexistingcalendarevent
*/
privateasyncupdateEvent(
calendar:any,
parameters:Record<string,any>
):Promise<ExecutionResult>{
try{
const{
eventId,
summary,
description,
startDateTime,
endDateTime,
timeZone,
attendees,
location,
calendarId="primary",
}=parameters;

if(!eventId){
return{
success:false,
error:"Missingrequiredparameter:eventId",
};
}

//First,fetchtheexistingevent
constexistingEvent=awaitcalendar.events.get({
calendarId,
eventId,
});

//Constructupdatedeventobject,preservingexistingvaluesifnotprovided
constupdatedEvent:any={
summary:summary??existingEvent.data.summary,
description:description??existingEvent.data.description,
location:location??existingEvent.data.location,
start:startDateTime
?{
dateTime:startDateTime,
timeZone:timeZone??existingEvent.data.start.timeZone,
}
:existingEvent.data.start,
end:endDateTime
?{
dateTime:endDateTime,
timeZone:timeZone??existingEvent.data.end.timeZone,
}
:existingEvent.data.end,
};

//Updateattendeesifprovided
if(attendees&&Array.isArray(attendees)){
updatedEvent.attendees=attendees.map((email:string)=>({email}));
}elseif(existingEvent.data.attendees){
updatedEvent.attendees=existingEvent.data.attendees;
}

constresponse=awaitcalendar.events.update({
calendarId,
eventId,
requestBody:updatedEvent,
sendUpdates:"all",//Sendemailnotificationstoattendees
});

return{
success:true,
output:{
eventId:response.data.id,
htmlLink:response.data.htmlLink,
summary:response.data.summary,
start:response.data.start,
end:response.data.end,
updated:response.data.updated,
},
};
}catch(error){
return{
success:false,
error:`Failedtoupdateevent:${errorinstanceofError?error.message:"Unknownerror"}`,
};
}
}

/**
*Deleteacalendarevent
*/
privateasyncdeleteEvent(
calendar:any,
parameters:Record<string,any>
):Promise<ExecutionResult>{
try{
const{eventId,calendarId="primary"}=parameters;

if(!eventId){
return{
success:false,
error:"Missingrequiredparameter:eventId",
};
}

//Fetcheventdetailsbeforedeletionforconfirmation
constevent=awaitcalendar.events.get({
calendarId,
eventId,
});

awaitcalendar.events.delete({
calendarId,
eventId,
sendUpdates:"all",//Sendcancellationnotificationstoattendees
});

return{
success:true,
output:{
eventId,
deletedEvent:{
summary:event.data.summary,
start:event.data.start,
end:event.data.end,
},
message:"Eventdeletedsuccessfully",
},
};
}catch(error){
return{
success:false,
error:`Failedtodeleteevent:${errorinstanceofError?error.message:"Unknownerror"}`,
};
}
}
}
